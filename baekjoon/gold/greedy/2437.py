import sys

N = int(input())
inputs = [int(n) for n in input().split()]
inputs.sort()

"""
heechoi님 아이디어:
max_min을 1로 설정해두면 나중에 1을 더할 필요도, 초기 예외조건을 설정할 필요도 없음

내 원래 풀이:
max_min = inputs[0]
if max_min != 1:
	print(1)
	sys.exit(0)
for elem in inputs[1:]:
	if max_min + 1 >= elem:
		max_min += elem
	else:
		break
print(max_min + 1)
"""
max_min = 1
for elem in inputs:
	if max_min < elem:
		break
	max_min += elem
print(max_min)

"""
이미 어떤 추 집합에 대해 해를 알고 있다고 했을 때
하나를 추가하면 - 그 해 (최솟값)에 새로운 무게를 더한 값만 확인해보면 됨... 은 아님:
{1} 최솟값 2인데 {1, 3} 최솟값 5? ㄴㄴ 2가 나와야됨

{1, 3} 최솟값 2인데 {1, 3, 4} 여전히 2

{1, 1, 2} 최솟값 4, {1, 1, 2, 3} 최솟값 7

{1}: 2
{1, 2}: 4
{1, 2, 3}: 7


{1}: 2
{1, 3}: 2
{1, 3, 4}: 2

정렬한 후 부분집합에 더한다고 했을 때, 
이전 집합 S_{n-1}의 최솟값을 새로 추가하는 원소 a_n이 만들 수 없으면 최솟값은 유지됨

최솟값이 갱신된다면 어떻게?
이전 집합의 최솟값 = 그 범위까지 된다는 뜻.
새로운 원소를 추가했을 때 1~K_{n-1} + a_n가지는 보장됨

{1, 2}: 4
{1, 2, 4}: 8
1 2 3 4 5 6 7
{1, 2, 4, 4}: 12
8 9 10 11
{1, 2, 4, 4, 10}: 22

그러면 새로운 원소를 추가해서 최솟값이 갱신되는지를 보고 갱신된다면 더하기만 하면 됨.
갱신되지 않으면 거기서 종료.

1 1 2 3 6 7 30
{1}: 1
{1, 1}: 2
{1, 1, 2}: 4
"""