"""
# 풀이: 그리디

하나의 강의실에서 최대한 많은 수업이 있게 한다면 최소 개수의 강의실을 사용할 수 있다.
하나의 강의실에서 최대한 많은 수업이 있게 하는 방법은 가장 빨리 끝나는 강의를 선택하는 것이다.

# 이 문제가 그리디인 이유

> 탐욕적 선택 특성

(1) 하나의 강의실에서 최대한 많은 수업이 있게 하는 것이 최적해

최대한 적은 수의 강의실을 사용하는 최적해에서
하나의 강의실에 수업을 더한다고 해도, 전체 강의실 수는 변하지 않는다
= 탐욕적 선택 특성
= 하나의 강의실에 최대한 많은 수업을 선택하는 것으로 그리디 가능

(2) 최대한 빨리 끝나는 수업을 선택하면 최대한 많은 수업

하나의 강의실에서 최대한 많은 최적해에서 
첫 수업을 이보다 더 빨리 끝나는 수업으로 바꾼다고 하면, 전체 강의 수는 변하지 않는다
= 탐욕적 선택 특성
= 가장 빨리 끝나는 수업을 선택하는 것으로 그리디 가능

> 최적 부분 구조

하나의 강의실에 최대한 많은 수업을 넣는다면 남은 개수가 줄어드므로,
나머지 강의에 필요한 강의실 개수를 줄일 수 있다 = 최적 부분 구조

최대한 빨리 끝나는 수업을 선택한다면 남은 시간에 더 많은 수업을 선택할 수 있으므로,
하나의 강의실에서 할 수 있는 수업의 개수를 늘릴 수 있다 = 최적 부분 구조

# but 시간초과

최초의 코드는 최악의 경우에 O(n^2) 순회함 (last_end보다 빨리 시작하는 강의가 없는 경우)

힌트를 보니까 우선순위 큐에 대한 언급...

큐를 쓴다? 못찾겠다 으악. 구글: `백준 11000`

아...

# 여러 개의 강의실 운영하기

하나의 회의실에 최대한 많은 회의를 배정하는 "회의실 문제" 와는 다르게 접근해야 한다.
이 문제는 모든 수업을 배정하면서, 가장 작은 수의 강의실을 사용해야 한다. (강의실 개수가 무제한) 

수업을 빠트리지 않으려면 *빨리 시작하는 수업을 기준으로 정렬*하는 방법이 필요하다.
이 방식의 정당성을 평가하면 (최적 부분 구조는 생략),

> 탐욕적 선택 조건

모든 수업이 배정되려면 특정한 시간에 모든 수업이 병렬적으로 진행되어야 한다.
특정한 시간을 포함하는 모든 수업이 동시에 진행되려면
강의의 시작 시간 이전에 만들어진 모든 강의실을 효율적으로 사용해야 한다. 

최적해에서, 특정 수업의 시작 시간을 더 늦은 시간으로 바꾸어도 여전히 최적해이다.

# 결론

그리디 증명자체가 잘못됐다.
잘못된 그리디 방식을 올바르게 검증할 수 있는 방법은 뭘까?? 

문제를 잘못 이해함. 모든 수업이 배정되어야 한다는 조건이 필요!

"""

from heapq import heappush, heappop

N = int(input())

classes = list()
for _ in range(N):
	classes.append(tuple(map(int, input().split()) ))
classes.sort()

rooms = [classes[0][1],]
for i in range(1, N):
	start, end, = classes[i]
	if rooms[0] <= start:
		heappop(rooms)
	heappush(rooms, end)

print(len(rooms))